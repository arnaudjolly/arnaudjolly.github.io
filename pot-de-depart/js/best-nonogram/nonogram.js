/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Nonogram", [], factory);
	else if(typeof exports === 'object')
		exports["Nonogram"] = factory();
	else
		root["Nonogram"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/creator.js":
/*!************************!*\
  !*** ./src/creator.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Creator: () => (/* binding */ Creator)\n/* harmony export */ });\n/* harmony import */ var _src_puzzle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/puzzle.js */ \"./src/puzzle.js\");\n/* harmony import */ var _src_puzzle_cell_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/puzzle-cell.js */ \"./src/puzzle-cell.js\");\n/* harmony import */ var _src_solver_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/solver.js */ \"./src/solver.js\");\n/* harmony import */ var _src_utility_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/utility.js */ \"./src/utility.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n\n/**\r\n * @class\r\n * @type {Creator}\r\n * @this Creator\r\n *\r\n * creates nonogram puzzles\r\n *\r\n * @property {Puzzle} puzzle\r\n * @property {array} log\r\n * @property {number} creationTime\r\n * @property {number} solvingTime\r\n */\nvar Creator = /*#__PURE__*/function () {\n  function Creator() {\n    _classCallCheck(this, Creator);\n  }\n  _createClass(Creator, [{\n    key: \"createRandom\",\n    value:\n    // ######################################################################################\tpublic methods\n\n    /**\r\n     * populates the puzzles rows and columns with random, solvable values\r\n     *\r\n     * @param {number} width\r\n     * @param {number} height\r\n     * @param {number|null} density - a floating point number between 0 and 1 (optional) that controls the percentage of filled cell likelihood.\r\n     *                                    If not supplied a random value between 0.2 and 0.8 will be generated.\r\n     *                                    Note that this does not make a puzzle grid filled in by the percentage,\r\n     *                                    rather it's a 'suggestion' that is run through randomization on a cell-by-cell basis.\r\n     * @returns {Puzzle|Puzzle|class}\r\n     */\n    function createRandom(width, height, density) {\n      var start = new Date().getTime();\n      var puzzleValid = false,\n        densityValid = typeof density === 'number' && density >= 0 && density <= 1,\n        cellsFilled,\n        chanceOfCellFill,\n        solutionGrid,\n        rowArray,\n        cellValue,\n        solver,\n        i,\n        elapsed;\n      this.puzzle = new _src_puzzle_js__WEBPACK_IMPORTED_MODULE_0__.Puzzle(width, height);\n      this._reset();\n      while (puzzleValid === false) {\n        chanceOfCellFill = densityValid ? density : _src_utility_js__WEBPACK_IMPORTED_MODULE_3__.Utility.getRandomIntBetween(200, 800) / 1000;\n        solutionGrid = [];\n        rowArray = [];\n        cellsFilled = 0;\n        this._log('Creating random ' + this.puzzle.width + 'x' + this.puzzle.height + ' puzzle with density of ' + chanceOfCellFill + '...');\n\n        // create puzzle grid randomly using density as a factor\n\n        for (i = 0; i < this.puzzle.totalCells; i++) {\n          cellValue = Math.random() < chanceOfCellFill ? 1 : 0;\n          cellsFilled += cellValue;\n          if (i % this.puzzle.width === 0 && i > 0) {\n            solutionGrid.push(rowArray);\n            rowArray = [];\n          }\n          rowArray.push(cellValue);\n        }\n\n        // ensure that at least one cell is filled, and that not all of them are\n\n        if (cellsFilled === 0) {\n          this._log('Generated puzzle has no cells filled.  Trying again...');\n          continue;\n        } else if (cellsFilled === this.puzzle.totalCells) {\n          this._log('Generated puzzle has all cells filled.  Trying again...');\n          continue;\n        }\n\n        // populate the solution grid\n        solutionGrid.push(rowArray);\n\n        // populate the grid\n        this.puzzle = Creator._populatePuzzleFromGrid(this.puzzle, solutionGrid);\n\n        // ensure that puzzle is solvable\n        solver = new _src_solver_js__WEBPACK_IMPORTED_MODULE_2__.Solver(this.puzzle);\n        if (solver.solve()) {\n          puzzleValid = true;\n          elapsed = (new Date().getTime() - start) / 1000;\n          this._log('Puzzle is solvable - solved in ' + solver.elapsedTime + ' seconds');\n          this._logLine();\n          this._log('Puzzle generated in ' + elapsed + ' seconds.');\n          this.creationTime = elapsed;\n          this.solvingTime = solver.elapsedTime;\n        } else {\n          this._log('Puzzle cannot be solved.  Trying again...');\n        }\n        this._logLine();\n      }\n      this.puzzle.creator = this;\n      return this.puzzle;\n    }\n\n    /**\r\n     * - create a puzzle using a grid\r\n     *\r\n     * @param {array} grid - a multi-dimensional array representing rows and columns.\r\n     *                         for example a 2x2 grid could be represented by [[0,1],[0,0]]\r\n     * @throws - error if grid is invalid\r\n     */\n  }, {\n    key: \"createFromGrid\",\n    value: function createFromGrid(grid) {\n      var start = new Date();\n      var width = 0,\n        height = 0,\n        puzzle,\n        solver,\n        elapsed;\n      this._reset();\n      this._log('creating puzzle from grid array.');\n\n      // make sure grid is valid and get width & height\n      if (!(grid instanceof Array)) {\n        throw 'grid is not an array';\n      }\n      grid.forEach(function (row, rowKey) {\n        if (!(row instanceof Array)) {\n          throw 'grid is not a multi-dimensional array';\n        }\n        if (width === 0) {\n          width = row.length;\n        } else if (row.length !== width) {\n          throw 'row ' + rowKey + ' has an invalid length (' + row.length + ') - expecting ' + width;\n        }\n        height++;\n      });\n      this._log('grid is valid');\n      this._log('populating ' + width + 'x' + height + ' puzzle');\n      puzzle = new _src_puzzle_js__WEBPACK_IMPORTED_MODULE_0__.Puzzle(width, height);\n      this.puzzle = Creator._populatePuzzleFromGrid(puzzle, grid);\n      this.puzzle.creator = this;\n\n      // ensure that puzzle is solvable\n\n      solver = new _src_solver_js__WEBPACK_IMPORTED_MODULE_2__.Solver(this.puzzle);\n      if (solver.solve()) {\n        this._log('Puzzle is solvable.');\n        this._logLine();\n      } else {\n        this._log('Puzzle cannot be solved.');\n        this._logLine();\n        return false;\n      }\n      elapsed = (new Date().getTime() - start) / 1000;\n      this._log('Puzzle built and solved in ' + elapsed + ' seconds.');\n      this._logLine();\n      return this.puzzle;\n    }\n\n    /**\r\n     * - create a puzzle from a hint object\r\n     *\r\n     * @param {object} hints - structured as follows:\r\n     *                            {\r\n     *\t\t\t\t\t\t\t\t\trow: [[3], [5], [5], [2, 3], [1, 5], [2, 1, 1], [2, 5], [1, 3]],\r\n     *\t\t\t\t\t\t\t\t\tcolumn: [[1, 3], [4], [], [2, 3], [5, 2], [5, 2], [5, 2], [2, 3]]\r\n     *\t\t\t\t\t\t\t  }\r\n     * @param {array} hints.row\r\n     * @param {array} hints.column\r\n     * @throws - error if hints object is structured incorrectly\r\n     */\n  }, {\n    key: \"createFromHints\",\n    value: function createFromHints(hints) {\n      var _this = this;\n      var start = new Date();\n      var width, height, puzzle, solver, elapsed;\n      this._reset();\n      this._log('creating puzzle from hints');\n\n      // make sure row & column properties exist\n\n      if (_typeof(hints) !== 'object' || !hints.row || !hints.column) {\n        throw 'parameter passed to createFromHints() must be an object containing \"row\" and \"column\" properties';\n      } else if (!(hints.row instanceof Array) || !(hints.column instanceof Array)) {\n        throw 'hints.row or hints.column must be an array.';\n      }\n      this._log('found row and column hints');\n      width = hints.column.length;\n      height = hints.row.length;\n      puzzle = new _src_puzzle_js__WEBPACK_IMPORTED_MODULE_0__.Puzzle(width, height);\n      puzzle.rowHints = hints.row;\n      puzzle.columnHints = hints.column;\n      puzzle.creator = this;\n      this._log('populating ' + width + 'x' + height + ' puzzle');\n\n      // populate cells array\n\n      puzzle.grid.forEach(function (row, rowKey) {\n        row.forEach(function (column, columnKey) {\n          puzzle.cells.push(new _src_puzzle_cell_js__WEBPACK_IMPORTED_MODULE_1__.PuzzleCell({\n            index: rowKey * puzzle.width + columnKey,\n            column: columnKey,\n            row: rowKey\n          }));\n        });\n      });\n      this.puzzle = puzzle;\n\n      // ensure that puzzle is solvable\n\n      solver = new _src_solver_js__WEBPACK_IMPORTED_MODULE_2__.Solver(this.puzzle);\n      if (solver.solve()) {\n        this._log('Puzzle is solvable.');\n        this._logLine();\n      } else {\n        this._log('Puzzle cannot be solved.');\n        this._logLine();\n        return false;\n      }\n\n      // set solution on puzzle cells\n\n      solver.puzzle.cells.forEach(function (solvedCell, cellIndex) {\n        var puzzleCell = _this.puzzle.getCellByIndex(cellIndex);\n        puzzleCell.aiSolution = solvedCell.aiSolution;\n        puzzleCell.solution = solvedCell.aiSolution;\n      });\n      elapsed = (new Date().getTime() - start) / 1000;\n      this._log('Puzzle built and solved in ' + elapsed + ' seconds.');\n      this._logLine();\n      return this.puzzle;\n    }\n\n    // ######################################################################################\tprivate methods\n\n    /**\r\n     *\r\n     * @param {Puzzle} puzzle\r\n     * @param {array} grid - a multidimensional array\r\n     * @returns {Puzzle} puzzle\r\n     * @private\r\n     */\n  }, {\n    key: \"_log\",\n    value:\n    /**\r\n     *\r\n     * @param msg\r\n     * @private\r\n     */\n    function _log(msg) {\n      this.log.push(msg);\n    }\n\n    /**\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"_logLine\",\n    value: function _logLine() {\n      this.log.push('-----------------------------------');\n    }\n\n    /**\r\n     * @private\r\n     */\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      this.log = [];\n      this.creationTime = 0;\n      this.solvingTime = 0;\n    }\n  }], [{\n    key: \"_populatePuzzleFromGrid\",\n    value: function _populatePuzzleFromGrid(puzzle, grid) {\n      var columnHints, rowKey, row, columnKey, column, cell, currentVal, lastVal, rowHints, hintKey, hint;\n      puzzle.reset();\n      puzzle.grid = grid;\n      for (rowKey = 0; rowKey < puzzle.grid.length; rowKey++) {\n        row = puzzle.grid[rowKey];\n        rowHints = [];\n        puzzle.rowHints[rowKey] = [];\n        for (columnKey = 0; columnKey < row.length; columnKey++) {\n          column = row[columnKey];\n          currentVal = column;\n          lastVal = columnKey > 0 ? puzzle.grid[rowKey][columnKey - 1] : 0;\n\n          // populate cells\n\n          puzzle.cells.push(new _src_puzzle_cell_js__WEBPACK_IMPORTED_MODULE_1__.PuzzleCell({\n            index: rowKey * puzzle.width + columnKey,\n            column: columnKey,\n            row: rowKey,\n            solution: column\n          }));\n\n          // populate row hints\n\n          if (currentVal === 1 && lastVal === 0) {\n            rowHints.push(1);\n          } else if (currentVal === 0 && lastVal === 1) {\n            rowHints.push(0);\n          } else if (currentVal === 1 && lastVal === 1) {\n            rowHints[rowHints.length - 1]++;\n          }\n        }\n\n        // clean up row hints\n\n        for (hintKey = 0; hintKey < rowHints.length; hintKey++) {\n          hint = rowHints[hintKey];\n          if (hint > 0) {\n            puzzle.rowHints[rowKey].push(hint);\n          }\n        }\n      }\n\n      // populate column hints\n\n      for (columnKey = 0; columnKey < puzzle.width; columnKey++) {\n        puzzle.columnHints[columnKey] = [];\n        columnHints = [];\n        for (cell = columnKey; cell < puzzle.totalCells; cell += puzzle.width) {\n          row = Math.floor(cell / puzzle.width);\n          currentVal = puzzle.grid[row][columnKey];\n          lastVal = row > 0 ? puzzle.grid[row - 1][columnKey] : 0;\n          if (currentVal === 1 && lastVal === 0) {\n            columnHints.push(1);\n          } else if (currentVal === 0 && lastVal === 1) {\n            columnHints.push(0);\n          } else if (currentVal === 1 && lastVal === 1) {\n            columnHints[columnHints.length - 1]++;\n          }\n        }\n\n        // clean up column hints\n\n        for (hintKey = 0; hintKey < columnHints.length; hintKey++) {\n          hint = columnHints[hintKey];\n          if (hint > 0) {\n            puzzle.columnHints[columnKey].push(hint);\n          }\n        }\n      }\n      return puzzle;\n    }\n  }]);\n  return Creator;\n}();\n\n//# sourceURL=webpack://Nonogram/./src/creator.js?");

/***/ }),

/***/ "./src/gui-template.js":
/*!*****************************!*\
  !*** ./src/gui-template.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GuiTemplate: () => (/* binding */ GuiTemplate)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\r\n * @class\r\n * @type {GuiTemplate}\r\n * @this GuiTemplate\r\n *\r\n * @property {string} name\r\n * @property {string} path\r\n * @property {string} html\r\n * @property {array} loadedCallbacks\r\n * @property {Promise} loadedPromise - resolves once template has been loaded and parsed\r\n * @property {boolean} isLoaded\r\n */\nvar GuiTemplate = /*#__PURE__*/function () {\n  /**\r\n   * class for loading an html template\r\n   *\r\n   * @param name\r\n   * @param path\r\n   */\n  function GuiTemplate(name, path) {\n    _classCallCheck(this, GuiTemplate);\n    this.name = name;\n    this.path = path;\n    this.html = '';\n    this.onLoadedCallbacks = [];\n    this.isLoaded = false;\n    this.loadedPromise = null;\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  /**\r\n   * attach a callback to fire once template has loaded\r\n   *\r\n   * @param {function} callback\r\n   */\n  _createClass(GuiTemplate, [{\n    key: \"onLoad\",\n    value: function onLoad(callback) {\n      this.onLoadedCallbacks.push(callback);\n    }\n\n    /**\r\n     * fired when template is loaded.  executes all onLoad callbacks\r\n     */\n  }, {\n    key: \"fireOnLoaded\",\n    value: function fireOnLoaded() {\n      this.onLoadedCallbacks.forEach(function (callback) {\n        callback();\n      });\n    }\n\n    /**\r\n     * attempts to fetch a template specified by this.path\r\n     *\r\n     * @returns {Promise} - complete when template has been fetched and parsed\r\n     * @throws - error if template cannot be loaded\r\n     */\n  }, {\n    key: \"load\",\n    value: function load() {\n      var _this = this;\n      this.loadedPromise = new Promise(function (resolve) {\n        fetch(_this.path).then(function (response) {\n          if (response.ok) {\n            response.text().then(function (text) {\n              _this.html = text;\n              _this.isLoaded = true;\n              _this.fireOnLoaded();\n              resolve(_this.name + ' loaded and parsed');\n            });\n          } else {\n            throw 'loading failed for \"' + _this.path + '\"';\n          }\n        });\n      });\n      return this.loadedPromise;\n    }\n\n    /**\r\n     * get the html template as a DOM node\r\n     * @returns {HTMLDivElement}\r\n     */\n  }, {\n    key: \"getNode\",\n    value: function getNode() {\n      var div = document.createElement('div');\n      div.innerHTML = this.html;\n      return div;\n    }\n  }]);\n  return GuiTemplate;\n}();\n\n//# sourceURL=webpack://Nonogram/./src/gui-template.js?");

/***/ }),

/***/ "./src/gui.js":
/*!********************!*\
  !*** ./src/gui.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Gui: () => (/* binding */ Gui)\n/* harmony export */ });\n/* harmony import */ var _src_gui_template_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/gui-template.js */ \"./src/gui-template.js\");\n/* harmony import */ var _src_puzzle_library_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/puzzle-library.js */ \"./src/puzzle-library.js\");\n/* harmony import */ var _src_creator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/creator.js */ \"./src/creator.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n/**\r\n * @class\r\n * @type {Gui}\r\n * @this Gui\r\n *\r\n * provides a user interface for interacting with nonogram puzzles\r\n *\r\n * @property {Puzzle} puzzle\r\n * @property {HTMLElement} gridContainer - container element for the puzzle grid ui\r\n * @property {array} templates - array of GuiTemplate objects\r\n * @property {array} templatesLoaded - array of Promises from each loaded template\r\n * @property {string|null} theme - the theme to use, located in the themes/ directory\r\n * @property {string} themePath - the path to the specified theme located in themes/{theme}\r\n * @property {string} themeStylesheetPath - the path to the theme stylesheet located in themes/{theme}/styles.css\r\n * @property {string} themeTemplatesPath - the path to the theme template directory located in themes/{theme}/templates\r\n * @property {int} playerClickMode - whether to fill or cross a cell on click\r\n */\nvar Gui = /*#__PURE__*/function () {\n  /**\r\n   *\r\n   * @param {string|null} themePath - the path to the theme directory.  Defaults to ./themes/default\r\n   */\n  function Gui(themePath) {\n    var _this = this;\n    _classCallCheck(this, Gui);\n    var head = document.querySelector('head'),\n      link = document.createElement('link');\n\n    // set up board sizes\n    this.boardSizes = [{\n      name: 'Tiny',\n      handle: 'tiny',\n      size: 1\n    }, {\n      name: 'Small',\n      handle: 'small',\n      size: 2\n    }, {\n      name: 'Medium',\n      handle: 'medium',\n      size: 3\n    }, {\n      name: 'Large',\n      handle: 'large',\n      size: 4\n    }];\n    this.boardSize = this.boardSizes[2];\n\n    // set up theme\n    this.themePath = themePath || './themes/default';\n\n    // load theme stylesheet\n    this.themeStylesheetPath = this.themePath + '/styles.css';\n    link.rel = 'stylesheet';\n    link.type = 'text/css';\n    link.href = this.themeStylesheetPath;\n    head.prepend(link);\n\n    // set up templates\n    this.templatesLoaded = [];\n    this.themeTemplatesPath = this.themePath + '/templates';\n    this.templates = [new _src_gui_template_js__WEBPACK_IMPORTED_MODULE_0__.GuiTemplate('gameControls', this.themeTemplatesPath + '/controls-game.html'), new _src_gui_template_js__WEBPACK_IMPORTED_MODULE_0__.GuiTemplate('generateControls', this.themeTemplatesPath + '/controls-generate.html'), new _src_gui_template_js__WEBPACK_IMPORTED_MODULE_0__.GuiTemplate('console', this.themeTemplatesPath + '/console.html'), new _src_gui_template_js__WEBPACK_IMPORTED_MODULE_0__.GuiTemplate('previewGrid', this.themeTemplatesPath + '/preview-grid.html'), new _src_gui_template_js__WEBPACK_IMPORTED_MODULE_0__.GuiTemplate('puzzleGrid', this.themeTemplatesPath + '/puzzle-grid.html')];\n\n    // load templates\n    this.templates.forEach(function (template) {\n      _this.templatesLoaded.push(template.load());\n    });\n\n    // a set of selected cells while maintaining mousedown\n    this.selection = new Set();\n  }\n\n  // ######################################################################################\tpublic drawing methods\n\n  /**\r\n   * - draw all user interfaces once templates are loaded\r\n   */\n  _createClass(Gui, [{\n    key: \"draw\",\n    value: function draw(puzzle) {\n      var _this2 = this;\n      this.puzzle = puzzle;\n      Promise.all(this.templatesLoaded).then(function () {\n        _this2.drawGenerateControls();\n        _this2.drawPuzzle(puzzle);\n        _this2.drawGameControls();\n        _this2.drawConsole();\n      });\n    }\n\n    /**\r\n     * - draw the puzzle ui\r\n     *\r\n     * @param {Puzzle} puzzle\r\n     */\n  }, {\n    key: \"drawPuzzle\",\n    value: function drawPuzzle(puzzle) {\n      var _this3 = this;\n      Promise.all(this.templatesLoaded).then(function () {\n        var template = _this3._getTemplate('puzzleGrid');\n        _this3.puzzle = puzzle;\n        _this3.gridContainer = document.querySelector('[data-nonogram-puzzle-grid]');\n        if (!_this3.gridContainer) {\n          return;\n        }\n        var container = _this3.gridContainer,\n          node = template.getNode(),\n          theadThTemplate = node.querySelector('[data-nonogram-puzzle-grid-table-thead-th]'),\n          rowTemplate = node.querySelector('[data-nonogram-puzzle-grid-table-row]'),\n          cellClasses = {\n            tl: 0,\n            tr: _this3.puzzle.width - 1,\n            bl: _this3.puzzle.width * _this3.puzzle.height - _this3.puzzle.width,\n            br: _this3.puzzle.width * _this3.puzzle.height - 1\n          };\n\n        // table header\n        _this3.puzzle.columnHints.forEach(function (hints, columnIndex) {\n          var clonedTheadThTemplate = document.importNode(theadThTemplate.content, true),\n            theadTh = clonedTheadThTemplate.querySelector('th'),\n            fillDiv = theadTh.querySelector('.fill');\n          theadTh.setAttribute('data-column', columnIndex.toString());\n          theadTh.classList.add('hint', 'top');\n\n          // add hints\n          hints.forEach(function (hint) {\n            var span = document.createElement('span');\n            span.textContent = hint;\n            fillDiv.appendChild(span);\n          });\n          theadThTemplate.parentNode.insertBefore(theadTh, theadThTemplate);\n        });\n\n        // table rows\n\n        _this3.puzzle.grid.forEach(function (row, rowKey) {\n          var cells = _this3.puzzle.getRowCells(rowKey),\n            clonedRowTemplate = document.importNode(rowTemplate.content, true),\n            tr = clonedRowTemplate.querySelector('tr'),\n            cellTemplate = tr.querySelector('[data-nonogram-puzzle-grid-table-cell]'),\n            hintsFillDiv = tr.querySelector('[data-row-hints] .fill');\n          tr.setAttribute('data-row', rowKey.toString());\n\n          // hint cell\n          _this3.puzzle.rowHints[rowKey].forEach(function (hint) {\n            var span = document.createElement('span');\n            span.textContent = hint;\n            hintsFillDiv.appendChild(span);\n          });\n\n          // grid cells\n          cells.forEach(function (cell) {\n            var clonedCellTemplate = document.importNode(cellTemplate.content, true),\n              td = clonedCellTemplate.querySelector('td');\n            td.setAttribute('data-index', cell.index);\n            td.setAttribute('data-column', cell.column);\n            td.setAttribute('data-row', cell.row);\n            td.classList.add('puzzle-cell', 'flippable');\n            Object.keys(cellClasses).forEach(function (cssClass) {\n              if (cell.index === cellClasses[cssClass]) {\n                td.classList.add(cssClass);\n              }\n            });\n            tr.appendChild(td);\n          });\n          rowTemplate.parentNode.appendChild(tr);\n        });\n\n        // insert template\n        container.innerHtml = container.textContent = '';\n        container.appendChild(node);\n\n        // set board size\n        document.querySelector('[data-nonogram-puzzle-grid-table]').classList.add(_this3.boardSize.handle);\n        _this3._resizeBoardForAvailableScreen();\n        _this3._makePuzzlePlayable();\n        _this3.drawPreview('userSolution');\n      });\n    }\n\n    /**\r\n     *    - draw the game controls ui\r\n     */\n  }, {\n    key: \"drawGameControls\",\n    value: function drawGameControls() {\n      var _this4 = this;\n      Promise.all(this.templatesLoaded).then(function () {\n        var template = _this4._getTemplate('gameControls'),\n          container = document.querySelector('[data-nonogram-game-controls]'),\n          node = template.getNode();\n        var fillModeCheckbox;\n        if (!container) {\n          return;\n        }\n\n        // insert template\n        container.innerHtml = container.textContent = '';\n        container.appendChild(node);\n\n        // add event handlers\n        fillModeCheckbox = document.querySelector('#nonogram-puzzle-fill-mode');\n        fillModeCheckbox.addEventListener('change', function () {\n          var fillModeLabel = document.querySelector('[for=\"nonogram-puzzle-fill-mode\"]'),\n            prevActive = fillModeLabel.querySelector('.active'),\n            prevInactive = fillModeLabel.querySelector('.inactive');\n          prevActive.classList.remove('active');\n          prevActive.classList.add('inactive');\n          prevInactive.classList.remove('inactive');\n          prevInactive.classList.add('active');\n          if (fillModeCheckbox.checked) {\n            fillModeLabel.classList.add('on');\n            _this4.playerClickMode = 0;\n          } else {\n            fillModeLabel.classList.remove('on');\n            _this4.playerClickMode = 1;\n          }\n        });\n        window.removeEventListener('keyup', Gui._keypressCallback);\n        window.addEventListener('keyup', Gui._keypressCallback);\n      });\n    }\n\n    /**\r\n     * - draw puzzle generating/solving/resetting ui\r\n     */\n  }, {\n    key: \"drawGenerateControls\",\n    value: function drawGenerateControls() {\n      var _this5 = this;\n      Promise.all(this.templatesLoaded).then(function () {\n        var template = _this5._getTemplate('generateControls'),\n          container = document.querySelector('[data-nonogram-generate-controls]'),\n          node = template.getNode(),\n          widthSelect = node.querySelector('[data-nonogram-generate-width]'),\n          heightSelect = node.querySelector('[data-nonogram-generate-height]'),\n          widthOptions = node.querySelector('[data-nonogram-generate-width-options]'),\n          heightOptions = node.querySelector('[data-nonogram-generate-height-options]'),\n          chooseExampleSelect = node.querySelector('[data-nonogram-choose-predefined]'),\n          boardSizeSelect = node.querySelector('[data-nonogram-board-size]'),\n          boardSizeOptions = node.querySelector('[data-nonogram-board-size-options]');\n        var i, clonedWidthOptions, cloneHeightOptions, widthOption, heightOption, clonedExampleOptions, exampleOption, chooseSelect, boardSize, clonedSizeOptions, sizeOption, reset, solve, generate;\n        if (!container) {\n          return;\n        }\n\n        // populate width/height select elements\n        for (i = 5; i <= 30; i++) {\n          clonedWidthOptions = document.importNode(widthOptions.content, true);\n          cloneHeightOptions = document.importNode(heightOptions.content, true);\n          widthOption = clonedWidthOptions.querySelector('option');\n          widthOption.textContent = widthOption.value = i;\n          heightOption = cloneHeightOptions.querySelector('option');\n          heightOption.textContent = heightOption.value = i;\n          if (_this5.puzzle.width === i) {\n            widthOption.setAttribute('selected', 'selected');\n          }\n          if (_this5.puzzle.height === i) {\n            heightOption.setAttribute('selected', 'selected');\n          }\n          widthSelect.appendChild(widthOption);\n          heightSelect.appendChild(heightOption);\n        }\n\n        // populate predefined puzzles\n\n        Object.keys(_src_puzzle_library_js__WEBPACK_IMPORTED_MODULE_1__.PuzzleLibrary).forEach(function (puzzleName) {\n          clonedExampleOptions = document.importNode(widthOptions.content, true);\n          exampleOption = clonedExampleOptions.querySelector('option');\n          exampleOption.textContent = exampleOption.value = puzzleName;\n          if (puzzleName === _this5.selectedExample) {\n            exampleOption.setAttribute('selected', 'selected');\n          }\n          chooseExampleSelect.appendChild(exampleOption);\n        });\n\n        // populate board size\n        _this5.boardSizes.forEach(function (sizeObj) {\n          clonedSizeOptions = document.importNode(boardSizeOptions.content, true);\n          sizeOption = clonedSizeOptions.querySelector('option');\n          sizeOption.value = sizeObj.handle;\n          sizeOption.textContent = sizeObj.name;\n          if (sizeObj.handle === _this5.boardSize.handle) {\n            sizeOption.setAttribute('selected', 'selected');\n          }\n          boardSizeSelect.appendChild(sizeOption);\n        });\n\n        // insert template\n        container.innerHtml = container.textContent = '';\n        container.appendChild(node);\n\n        // add event handlers\n        generate = document.querySelector('[data-nonogram-generate-button]');\n        chooseSelect = document.querySelector('[data-nonogram-choose-predefined]');\n        boardSize = document.querySelector('[data-nonogram-board-size]');\n        reset = document.querySelector('[data-nonogram-game-reset]');\n        solve = document.querySelector('[data-nonogram-game-solve]');\n        generate.addEventListener('click', function () {\n          var widthSelect = document.querySelector('[data-nonogram-generate-width]'),\n            heightSelect = document.querySelector('[data-nonogram-generate-height]'),\n            width = widthSelect.value,\n            height = heightSelect.value,\n            creator = new _src_creator_js__WEBPACK_IMPORTED_MODULE_2__.Creator(),\n            puzzle = creator.createRandom(width, height, null);\n          _this5.selectedExample = null;\n          _this5.draw(puzzle);\n          _this5._resizeBoardForAvailableScreen();\n        });\n        chooseSelect.addEventListener('change', function () {\n          var creator = new _src_creator_js__WEBPACK_IMPORTED_MODULE_2__.Creator();\n          var puzzleDef, puzzle;\n          if (chooseSelect.value !== '') {\n            Object.keys(_src_puzzle_library_js__WEBPACK_IMPORTED_MODULE_1__.PuzzleLibrary).forEach(function (puzzleName) {\n              if (chooseSelect.value === puzzleName) {\n                puzzleDef = _src_puzzle_library_js__WEBPACK_IMPORTED_MODULE_1__.PuzzleLibrary[puzzleName];\n                _this5.selectedExample = puzzleName;\n                if (puzzleDef.solutionGrid) {\n                  puzzle = creator.createFromGrid(puzzleDef.solutionGrid);\n                } else if (puzzleDef.hints) {\n                  puzzle = creator.createFromHints(puzzleDef.hints);\n                }\n              }\n            });\n            if (puzzle) {\n              _this5.draw(puzzle);\n              _this5._resizeBoardForAvailableScreen();\n            }\n          }\n        });\n        boardSize.addEventListener('change', function () {\n          _this5.boardSizes.forEach(function (item) {\n            if (item.handle === boardSize.value) {\n              _this5._changeBoardSize(item);\n            }\n          });\n        });\n        reset.addEventListener('click', function () {\n          _this5._resetPuzzle();\n        });\n        solve.addEventListener('click', function () {\n          _this5.drawSolution();\n          _this5.drawPreview('solution');\n          _this5._showPuzzleSolved();\n        });\n      });\n    }\n\n    /**\r\n     * - draw the console and populate with Creator _log\r\n     */\n  }, {\n    key: \"drawConsole\",\n    value: function drawConsole() {\n      var _this6 = this;\n      Promise.all(this.templatesLoaded).then(function () {\n        var template = _this6._getTemplate('console'),\n          container = document.querySelector('[data-nonogram-console]'),\n          node = template.getNode(),\n          output = node.querySelector('[data-nonogram-console-output]'),\n          line = node.querySelector('[data-nonogram-console-line]');\n        if (!container) {\n          return;\n        }\n        if (_this6.puzzle.creator instanceof _src_creator_js__WEBPACK_IMPORTED_MODULE_2__.Creator) {\n          _this6.puzzle.creator.log.forEach(function (text) {\n            var clonedLine = document.importNode(line.content, true),\n              code = clonedLine.querySelector('code');\n            code.textContent = text.toString();\n            output.appendChild(code);\n          });\n        }\n\n        // insert template\n        container.innerHtml = container.textContent = '';\n        container.appendChild(node);\n      });\n    }\n\n    /**\r\n     * - draw the preview grid for the current state of the puzzle\r\n     *\r\n     * @param solutionType\r\n     */\n  }, {\n    key: \"drawPreview\",\n    value: function drawPreview(solutionType) {\n      var _this7 = this;\n      Promise.all(this.templatesLoaded).then(function () {\n        var template = _this7._getTemplate('previewGrid'),\n          container = document.querySelector('[data-nonogram-preview-grid]'),\n          node = template.getNode();\n\n        // insert template\n\n        container.innerHtml = container.textContent = '';\n        container.appendChild(node.querySelector('[data-nonogram-preview]'));\n\n        // draw preview canvas\n\n        var canvas = document.querySelector('[data-nonogram-preview-canvas]'),\n          ctx = canvas.getContext('2d'),\n          parentContainer = canvas.parentElement.parentElement.parentElement,\n          parentWidth = parentContainer.offsetWidth,\n          parentHeight = parentContainer.offsetHeight,\n          containerRatio = parentWidth / parentHeight,\n          puzzleRatio = _this7.puzzle.width / _this7.puzzle.height;\n        var cellSize;\n        if (containerRatio > puzzleRatio) {\n          cellSize = Math.floor(parentHeight / _this7.puzzle.height);\n        } else {\n          cellSize = Math.floor(parentWidth / _this7.puzzle.width);\n        }\n        canvas.width = cellSize * _this7.puzzle.width;\n        canvas.height = cellSize * _this7.puzzle.height;\n        _this7.puzzle.cells.forEach(function (cell) {\n          if (cell[solutionType] === 1) {\n            ctx.fillRect(cell.column * cellSize, cell.row * cellSize, cellSize, cellSize);\n          }\n        });\n      });\n    }\n\n    /**\r\n     * - draw the solution to the current puzzle\r\n     */\n  }, {\n    key: \"drawSolution\",\n    value: function drawSolution() {\n      var _this8 = this;\n      Promise.all(this.templatesLoaded).then(function () {\n        var filledTds = _this8.gridContainer.querySelectorAll('td.filled');\n        filledTds.forEach(function (td) {\n          td.classList.remove('filled', 'solution-positive', 'solution-negative', 'user-positive', 'user-negative', 'flipped');\n        });\n        _this8.puzzle.cells.forEach(function (cell) {\n          var cellElem = _this8.gridContainer.querySelector('td[data-index=\"' + cell.index + '\"]');\n          cell.userSolution = cell.solution;\n          cellElem.classList.add('user-solved');\n          if (cell.solution === 1) {\n            cellElem.classList.add('solution-positive', 'user-positive', 'flipped');\n          } else {\n            cellElem.classList.add('solution-negative', 'user-negative');\n          }\n        });\n      });\n    }\n\n    // ######################################################################################\tprivate methods\n\n    /**\r\n     *\r\n     * @param {object} boardSize\r\n     * @private\r\n     */\n  }, {\n    key: \"_changeBoardSize\",\n    value: function _changeBoardSize(boardSize) {\n      var puzzleTable = document.querySelector('[data-nonogram-puzzle-grid-table]'),\n        sizeSelect = document.querySelector('[data-nonogram-board-size]');\n      if (puzzleTable && sizeSelect) {\n        puzzleTable.classList.remove('tiny', 'small', 'medium', 'large');\n        puzzleTable.classList.add(boardSize.handle);\n        sizeSelect.value = boardSize.handle;\n        this.boardSize = boardSize;\n        this.drawPreview();\n      }\n    }\n\n    /**\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"_resizeBoardForAvailableScreen\",\n    value: function _resizeBoardForAvailableScreen() {\n      var table = this.gridContainer.querySelector('.nonogram-puzzle-grid'),\n        availableWidth = this.gridContainer.clientWidth,\n        sortedBoardSizes = this.boardSizes.sort(function (a, b) {\n          return a.size > b.size ? -1 : 1;\n        });\n      var i;\n      if (table.clientWidth > availableWidth) {\n        for (i = 0; i < sortedBoardSizes.length; i++) {\n          if (sortedBoardSizes[i].size < this.boardSize.size) {\n            this._changeBoardSize(sortedBoardSizes[i]);\n          }\n          if (table.clientWidth <= availableWidth) {\n            break;\n          }\n        }\n      }\n      this.drawConsole();\n    }\n\n    /**\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"_makePuzzlePlayable\",\n    value: function _makePuzzlePlayable() {\n      var _this9 = this;\n      var table = this.gridContainer.querySelector('.nonogram-puzzle-grid'),\n        cells = this.gridContainer.querySelectorAll('.nonogram-puzzle-grid td.puzzle-cell'),\n        allCells = this.gridContainer.querySelectorAll('.nonogram-puzzle-grid td');\n      this.playerClickMode = 1;\n\n      // set css classes and event handlers for puzzle cells\n\n      cells.forEach(function (cellElem) {\n        cellElem.classList.add('playable');\n\n        // highlight row/column on mouse hover\n\n        cellElem.addEventListener('mouseenter', function (e) {\n          var hoverCell = e.currentTarget,\n            row = hoverCell.getAttribute('data-row'),\n            column = hoverCell.getAttribute('data-column');\n          var cellRef = \"\".concat(column, \",\").concat(row);\n          allCells.forEach(function (cellElem) {\n            var actualCellRow = cellElem.getAttribute('data-row'),\n              actualCellColumn = cellElem.getAttribute('data-column');\n            if (actualCellRow === row && actualCellColumn === column && !_this9.selection.has(cellRef)) {\n              _this9.selection.add(cellRef);\n              cellElem.click();\n            }\n            if (actualCellRow === row || actualCellColumn === column) {\n              cellElem.classList.add('row-column-highlight');\n            } else {\n              cellElem.classList.remove('row-column-highlight');\n            }\n          });\n        });\n\n        // add cell click event handler\n\n        cellElem.addEventListener('click', function (e) {\n          var cellElem = e.currentTarget,\n            cellIndex = cellElem.getAttribute('data-index'),\n            cell = _this9.puzzle.getCellByIndex(cellIndex),\n            solvedP = document.querySelector('[data-nonogram-puzzle-grid-solved]');\n          e.preventDefault();\n          cell.userSolution = cell.userSolution === _this9.playerClickMode ? null : _this9.playerClickMode;\n          table.classList.remove('solved');\n          cellElem.classList.remove('user-solved', 'user-positive', 'user-negative', 'solution-positive', 'solution-negative');\n          if (cell.userSolution === 1) {\n            cellElem.classList.add('user-solved', 'user-positive');\n          } else if (cell.userSolution === 0) {\n            cellElem.classList.add('user-solved', 'user-negative');\n          }\n          cellElem.classList.toggle('flipped');\n          _this9.drawPreview('userSolution');\n          if (_this9.puzzle.checkUserSolution()) {\n            _this9._showPuzzleSolved();\n          } else {\n            solvedP.textContent = '';\n          }\n        });\n      });\n\n      // remove highlighted cells on puzzle grid mouseout\n\n      table.addEventListener('mouseleave', function () {\n        allCells.forEach(function (cellElem) {\n          cellElem.classList.remove('row-column-highlight');\n        });\n      });\n      table.addEventListener('mousedown', function (e) {});\n      table.addEventListener('mouseup', function () {\n        _this9.selection.clear();\n      });\n    }\n\n    /**\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"_resetPuzzle\",\n    value: function _resetPuzzle() {\n      var cellElements = this.gridContainer.querySelectorAll('.nonogram-puzzle-grid td.puzzle-cell'),\n        puzzleGrid = this.gridContainer.querySelector('.nonogram-puzzle-grid'),\n        solvedP = document.querySelector('[data-nonogram-puzzle-grid-solved]');\n      puzzleGrid.classList.remove('solved');\n      solvedP.textContent = '';\n      this.puzzle.cells.forEach(function (cell) {\n        cell.userSolution = null;\n      });\n      cellElements.forEach(function (cellElem) {\n        cellElem.classList.remove('user-solved', 'user-positive', 'user-negative', 'solution-positive', 'solution-negative');\n      });\n      this.gridContainer.querySelector('[data-nonogram-preview-grid]').innerHTML = '';\n      this.drawPreview('userSolution');\n    }\n\n    /**\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"_showPuzzleSolved\",\n    value: function _showPuzzleSolved() {\n      var grid = this.gridContainer.querySelector('.nonogram-puzzle-grid'),\n        tableCells = document.querySelectorAll('[data-nonogram-puzzle-grid-table] .puzzle-cell'),\n        solvedP = document.querySelector('[data-nonogram-puzzle-grid-solved]');\n      tableCells.forEach(function (cellElem) {\n        cellElem.classList.remove('row-column-highlight');\n      });\n      grid.classList.add('solved');\n      solvedP.textContent = 'Solved!';\n    }\n\n    /**\r\n     *\r\n     * @param name\r\n     * @returns {GuiTemplate}\r\n     * @throws - error if template could not be found\r\n     * @private\r\n     */\n  }, {\n    key: \"_getTemplate\",\n    value: function _getTemplate(name) {\n      var ret = this.templates.find(function (template) {\n        return template.name === name;\n      });\n      if (!(ret instanceof _src_gui_template_js__WEBPACK_IMPORTED_MODULE_0__.GuiTemplate)) {\n        throw '\"' + name + '\" template not found.';\n      }\n      return ret;\n    }\n\n    /**\r\n     * handle window keypress events\r\n     *\r\n     * @param {KeyboardEvent} e\r\n     * @private\r\n     */\n  }], [{\n    key: \"_keypressCallback\",\n    value: function _keypressCallback(e) {\n      if (e.key && e.key === 'x') {\n        document.querySelector('#nonogram-puzzle-fill-mode').dispatchEvent(new MouseEvent('click'));\n      }\n    }\n  }]);\n  return Gui;\n}();\n\n//# sourceURL=webpack://Nonogram/./src/gui.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Creator: () => (/* reexport safe */ _src_creator_js__WEBPACK_IMPORTED_MODULE_1__.Creator),\n/* harmony export */   Gui: () => (/* reexport safe */ _src_gui_js__WEBPACK_IMPORTED_MODULE_3__.Gui),\n/* harmony export */   Puzzle: () => (/* reexport safe */ _src_puzzle_js__WEBPACK_IMPORTED_MODULE_0__.Puzzle),\n/* harmony export */   Solver: () => (/* reexport safe */ _src_solver_js__WEBPACK_IMPORTED_MODULE_2__.Solver)\n/* harmony export */ });\n/* harmony import */ var _src_puzzle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/puzzle.js */ \"./src/puzzle.js\");\n/* harmony import */ var _src_creator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/creator.js */ \"./src/creator.js\");\n/* harmony import */ var _src_solver_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/solver.js */ \"./src/solver.js\");\n/* harmony import */ var _src_gui_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/gui.js */ \"./src/gui.js\");\n\n\n\n\n\n\n//# sourceURL=webpack://Nonogram/./src/index.js?");

/***/ }),

/***/ "./src/puzzle-cell.js":
/*!****************************!*\
  !*** ./src/puzzle-cell.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PuzzleCell: () => (/* binding */ PuzzleCell)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n/**\r\n * @class\r\n * @type {PuzzleCell}\r\n * @this PuzzleCell\r\n *\r\n * a container representing a single cell in the puzzle grid\r\n *\r\n * @property {number} index\r\n * @property {number} column\r\n * @property {number} row\r\n * @property {*} solution - null, 0, or 1\r\n * @property {*} userSolution - null, 0, or 1\r\n * @property {*} aiSolution - null, 0, or 1\r\n */\nvar PuzzleCell = /*#__PURE__*/_createClass(function PuzzleCell(params) {\n  _classCallCheck(this, PuzzleCell);\n  this.index = -1;\n  this.column = -1;\n  this.row = -1;\n  this.solution = null;\n  this.userSolution = null;\n  this.aiSolution = null;\n  Object.assign(this, params);\n});\n\n//# sourceURL=webpack://Nonogram/./src/puzzle-cell.js?");

/***/ }),

/***/ "./src/puzzle-library.js":
/*!*******************************!*\
  !*** ./src/puzzle-library.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PuzzleLibrary: () => (/* binding */ PuzzleLibrary)\n/* harmony export */ });\n\n\n/**\r\n *\r\n * @type {{'Large Example 1': {hints: {column: *[], row: *[]}, width: number, height: number}, 'Small Example 2': {hints: {column: *[], row: *[]}, width: number, height: number}, 'Medium Example 1': {hints: {column: *[], row: *[]}, width: number, height: number}, 'Small Example 1': {solutionGrid: *[], width: number, height: number}, 'Medium Example 2': {hints: {column: *[], row: *[]}, width: number, height: number}, 'Small Example 3': {hints: {column: *[], row: *[]}, width: number, height: number}}}\r\n */\nvar PuzzleLibrary = {\n  \"Arnaud\": {\n    width: 26,\n    height: 10,\n    hints: {\n      row: [[5, 5, 5, 5], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 5, 4, 4], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [5, 1, 1, 1, 5]],\n      column: [[10], [1, 1], [1, 1], [1, 1], [1, 1], [], [], [10], [1, 1], [1, 1], [1, 1], [10], [], [], [10], [1, 1], [1, 1], [1, 1], [1], [], [], [10], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1]]\n    }\n  },\n  \"Small Example 1\": {\n    width: 8,\n    height: 8,\n    solutionGrid: [[0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1], [1, 1, 0, 0, 1, 1, 1, 0], [0, 1, 0, 1, 1, 1, 1, 1], [1, 1, 0, 1, 0, 0, 0, 1], [1, 1, 0, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 1, 0]]\n  },\n  \"Small Example 2\": {\n    width: 8,\n    height: 8,\n    hints: {\n      row: [[3], [5], [5], [2, 3], [1, 5], [2, 1, 1], [2, 5], [1, 3]],\n      column: [[1, 3], [4], [], [2, 3], [5, 2], [5, 2], [5, 2], [2, 3]]\n    }\n  },\n  \"Small Example 3\": {\n    width: 10,\n    height: 10,\n    hints: {\n      column: [[3], [1, 1], [1], [6], [8], [2, 1], [4, 1], [10], [3, 1], [3]],\n      row: [[4], [5], [2, 3], [2, 3], [2, 1], [2, 1], [2, 1], [10], [1, 1, 1], [2, 1, 1]]\n    }\n  },\n  \"Medium Example 1\": {\n    width: 16,\n    height: 18,\n    hints: {\n      column: [[5], [4, 3, 3], [7, 6, 2], [4, 3, 4, 1], [3, 2, 4, 1, 2], [2, 6, 4], [3, 3, 1, 1], [4, 6, 4], [6, 4, 1, 1], [4, 3, 4, 1], [7, 6, 2], [4, 3, 3], [5], [3], [5, 3, 3], [2, 4, 1, 2]],\n      row: [[5], [9], [3, 5], [3, 5, 1], [4, 4, 2], [2, 1, 1, 2, 1], [2, 2, 1], [2, 3, 2, 1], [7, 2], [9, 1], [2, 2, 2, 2, 2], [3, 2, 2, 3, 2], [4, 1, 1, 6], [1, 2, 2, 2], [16], [2, 1, 1, 1, 1, 2, 1], [2, 2, 2, 2, 2], [9, 1]]\n    }\n  },\n  \"Medium Example 2\": {\n    width: 15,\n    height: 15,\n    hints: {\n      column: [[4], [3, 1], [2, 3], [1, 2, 2], [1, 2, 1], [1, 1, 1, 1], [4, 3, 3], [2, 2, 4, 3], [1, 2, 5, 1], [1, 2, 4, 1], [1, 2, 5, 1], [2, 2, 4, 3], [9, 3], [5, 1, 1], [6, 1]],\n      row: [[4, 5], [3, 2, 2], [2, 1, 1], [1, 4, 3], [2, 9], [2, 8], [2, 3], [12], [1, 7, 1], [9], [5], [1, 1], [2, 2], [3, 3], [1, 7, 1]]\n    }\n  },\n  \"Large Example 1\": {\n    width: 30,\n    height: 30,\n    hints: {\n      column: [[19, 9], [13, 1, 2, 1, 5], [11, 4, 1, 1, 2, 3], [10, 6, 1, 4, 1, 1], [9, 7, 1, 1, 3, 2], [3, 4, 11, 1, 6], [2, 1, 2, 3, 3, 3, 7], [2, 2, 1, 2, 4, 3, 8], [3, 2, 2, 1, 2, 6, 7], [1, 3, 3, 4, 1, 4, 4, 1], [5, 4, 2, 5, 2, 2], [1, 3, 11, 1, 2, 4], [3, 2, 14, 5], [2, 2, 1, 14, 7], [1, 2, 2, 2, 10, 2], [2, 1, 3, 2, 6, 3, 3], [5, 6, 6, 2, 2, 4], [6, 4, 4, 3, 3, 3], [6, 3, 2, 1, 1, 3, 5, 2], [6, 1, 2, 2, 2, 2, 2, 3], [7, 1, 9, 2, 4], [7, 3, 1, 2, 2, 3], [8, 2, 5, 4, 3], [6, 1, 7, 11], [5, 1, 3, 2, 12], [5, 2, 2, 2, 3, 11], [4, 5, 4, 3, 10], [3, 14, 10], [3, 3, 5, 2, 9], [4, 3, 3, 10]],\n      row: [[10, 19], [9, 1, 2, 15], [6, 1, 1, 1, 14], [5, 2, 3, 2, 11, 1], [6, 7, 11, 1], [7, 5, 7, 3], [8, 4, 3, 4], [6, 4, 5, 1, 4, 1], [5, 8, 6, 2, 1], [4, 10, 3, 3, 3, 1], [3, 3, 5, 2, 4, 2, 2], [2, 3, 3, 3, 2, 4, 2, 3], [2, 3, 1, 1, 5, 2, 1, 6], [1, 4, 3, 4, 2, 2, 2, 4], [1, 4, 3, 4, 5, 3, 3], [1, 5, 5, 2, 1, 4, 1, 1], [1, 15, 3, 2, 3, 1], [2, 4, 7, 2, 2, 3, 1], [1, 4, 4, 7, 2, 1, 3], [1, 2, 3, 4, 3, 3, 1], [1, 1, 3, 5, 2, 6, 1], [1, 1, 1, 4, 4, 9], [2, 3, 1, 1, 1, 9], [1, 2, 4, 1, 1, 6, 8], [1, 10, 1, 7, 7], [2, 8, 2, 1, 2, 1, 7], [3, 6, 3, 1, 1, 1, 7], [4, 4, 4, 3, 11], [3, 5, 20], [2, 7, 19]]\n    }\n  }\n};\n\n//# sourceURL=webpack://Nonogram/./src/puzzle-library.js?");

/***/ }),

/***/ "./src/puzzle-line.js":
/*!****************************!*\
  !*** ./src/puzzle-line.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PuzzleLine: () => (/* binding */ PuzzleLine)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n/**\r\n * @class\r\n * @type {PuzzleLine}\r\n * @this PuzzleLine\r\n *\r\n * a container representing a complete row or column of grid cells\r\n *\r\n * @property {string} type - either 'row' or 'column'\r\n * @property {number} index - the column or row index\r\n * @property {number} length\r\n * @property {number} minimumSectionLength\r\n * @property {array} sections\r\n * @property {array} cells\r\n * @property {boolean} solved\r\n */\nvar PuzzleLine = /*#__PURE__*/_createClass(function PuzzleLine(params) {\n  _classCallCheck(this, PuzzleLine);\n  this.type = '';\n  this.index = -1;\n  this.length = 0;\n  this.minimumSectionLength = 0;\n  this.sections = [];\n  this.cells = [];\n  this.solved = false;\n  Object.assign(this, params);\n});\n\n//# sourceURL=webpack://Nonogram/./src/puzzle-line.js?");

/***/ }),

/***/ "./src/puzzle.js":
/*!***********************!*\
  !*** ./src/puzzle.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Puzzle: () => (/* binding */ Puzzle)\n/* harmony export */ });\n/* harmony import */ var _src_utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/utility.js */ \"./src/utility.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n/**\r\n * @class\r\n * @type {Puzzle}\r\n * @this Puzzle\r\n *\r\n * the main puzzle class containing the grid of cells, row/column hints, etc.\r\n *\r\n * @property {number} width\r\n * @property {number} height\r\n * @property {number} totalCells\r\n * @property {array} cells\r\n * @property {array} rowHints\r\n * @property {array} columnHints\r\n * @property {Creator|null} creator\r\n * @property {array} grid - a multi-dimensional array representing rows and columns.\r\n *                   for example a 2x2 grid could be represented by [[0,1],[0,0]]\r\n */\nvar Puzzle = /*#__PURE__*/function () {\n  /**\r\n   * @param {number} width - an integer >= 1 specifying the number of rows\r\n   * @param {number} height - an integer >= 1 specifying the number of columns\r\n   * @throws - error if width or height are invalid\r\n   */\n  function Puzzle(width, height) {\n    _classCallCheck(this, Puzzle);\n    if (typeof width === 'undefined' || typeof height === 'undefined') {\n      throw 'width and height are required constructor parameters.';\n    } else if (width <= 0 || height <= 0 || width === 1 && height === 1) {\n      throw 'invalid dimensions: ' + width.toString() + ' x ' + height.toString();\n    }\n    this.width = typeof width === 'number' ? width : parseInt(width.toString(), 10);\n    this.height = typeof height === 'number' ? height : parseInt(height.toString(), 10);\n    this.totalCells = this.width * this.height;\n    this.reset();\n  }\n\n  /**\r\n   * empty all arrays and create zero-filled multidimensional grid array\r\n   */\n  _createClass(Puzzle, [{\n    key: \"reset\",\n    value: function reset() {\n      var _this = this;\n      var zeroFill = _src_utility_js__WEBPACK_IMPORTED_MODULE_0__.Utility.getZeroFilledArray;\n      this.creator = null;\n      this.cells = [];\n      this.rowHints = [];\n      this.columnHints = [];\n      this.grid = zeroFill(this.height).map(function () {\n        return zeroFill(_this.width);\n      });\n    }\n\n    /**\r\n     * @returns {boolean}\r\n     */\n  }, {\n    key: \"checkUserSolution\",\n    value: function checkUserSolution() {\n      return this.cells.every(function (cell) {\n        // cell.solution will be 0 or 1, but cell.userSolution might be null, 0 or 1\n        var userValue = cell.userSolution === 1 ? 1 : 0;\n        return cell.solution === userValue;\n      });\n    }\n\n    /**\r\n     * @param {number} row\r\n     * @returns {array|boolean}\r\n     */\n  }, {\n    key: \"getRowCells\",\n    value: function getRowCells(row) {\n      var cells = [];\n      var start = row * this.width,\n        end = start + this.width,\n        i;\n      for (i = start; i < end; i++) {\n        cells.push(this.cells[i]);\n      }\n      return cells.length > 0 ? cells : false;\n    }\n\n    /**\r\n     * @param {number} column\r\n     * @returns {array|boolean}\r\n     */\n  }, {\n    key: \"getColumnCells\",\n    value: function getColumnCells(column) {\n      var cells = [];\n      var i;\n      for (i = column; i < this.cells.length; i += this.width) {\n        cells.push(this.cells[i]);\n      }\n      return cells.length > 0 ? cells : false;\n    }\n\n    /**\r\n     * @param {number|string} index\r\n     * @returns {object|boolean}\r\n     */\n  }, {\n    key: \"getCellByIndex\",\n    value: function getCellByIndex(index) {\n      var indexInt = typeof index !== 'number' ? parseInt(index, 10) : index;\n      return this.cells[indexInt] ? this.cells[indexInt] : false;\n    }\n  }]);\n  return Puzzle;\n}();\n\n//# sourceURL=webpack://Nonogram/./src/puzzle.js?");

/***/ }),

/***/ "./src/solver.js":
/*!***********************!*\
  !*** ./src/solver.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Solver: () => (/* binding */ Solver)\n/* harmony export */ });\n/* harmony import */ var _src_puzzle_line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/puzzle-line.js */ \"./src/puzzle-line.js\");\n/* harmony import */ var _src_utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/utility.js */ \"./src/utility.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n/**\r\n * @class\r\n * @type {Solver}\r\n * @this Solver\r\n *\r\n * a class that solves nonogram puzzles using logical techniques a human might use\r\n *\r\n * @property {Puzzle} puzzle\r\n * @property {number} elapsedTime\r\n * @property {boolean} isReset\r\n * @property {array} lines\r\n * @property {array} solutionLog\r\n */\nvar Solver = /*#__PURE__*/function () {\n  /**\r\n   * @param {Puzzle} puzzle\r\n   */\n  function Solver(puzzle) {\n    _classCallCheck(this, Solver);\n    this.puzzle = puzzle;\n    this._reset();\n  }\n\n  /**\r\n   *\r\n   * @returns {boolean}\r\n   */\n  _createClass(Solver, [{\n    key: \"solve\",\n    value: function solve() {\n      var start = new Date().getTime();\n      var lastProgress = -1,\n        pass = 1,\n        solved,\n        passStart,\n        passEnd,\n        end,\n        passElapsedTime,\n        totalElapsedTime,\n        lineKey,\n        line;\n      if (!this.isReset) {\n        this._reset();\n      }\n      this.isReset = false;\n      this._log('Starting solve algorithm', 'info');\n      while (this._getProgress() > lastProgress && this._getTotalSolved() < this.puzzle.cells.length) {\n        passStart = new Date().getTime();\n        lastProgress = this._getProgress();\n        for (lineKey = 0; lineKey < this.lines.length; lineKey++) {\n          line = this.lines[lineKey];\n          if (!line.solved) {\n            this.eliminateImpossibleFits(line);\n          }\n          if (!line.solved) {\n            this.findKnownPositivesAndNegatives(line);\n          }\n          if (!line.solved) {\n            this.findSectionDefiningChains(line);\n          }\n          if (!line.solved) {\n            this.findAnchoredSections(line);\n          }\n          if (!line.solved) {\n            this.findCompletedSections(line);\n          }\n          if (!line.solved) {\n            this.findCompletedLines(line);\n          }\n        }\n        passEnd = new Date().getTime();\n        passElapsedTime = (passEnd - passStart) / 1000;\n        this._log('Pass ' + pass + ' completed in ' + passElapsedTime + ' seconds :: ' + this._getTotalSolved() + '/' + this.puzzle.cells.length + ' cells solved', 'info');\n        pass++;\n      }\n      solved = this._getTotalSolved() === this.puzzle.cells.length;\n      end = new Date().getTime();\n      totalElapsedTime = (end - start) / 1000;\n      this._log('Solve algorithm finished in ' + totalElapsedTime + ' seconds.', 'info');\n      if (solved) {\n        this._log('Solution Found.', 'success');\n      } else {\n        this._log('Could not find solution.', 'failure');\n      }\n      this.elapsedTime = totalElapsedTime;\n      return solved;\n    }\n\n    //\t#############################################################################################\tsolution algorithms\n\n    /**\r\n     *\r\n     * @param {PuzzleLine} line\r\n     */\n  }, {\n    key: \"eliminateImpossibleFits\",\n    value: function eliminateImpossibleFits(line) {\n      var minimumStartIndex = 0,\n        maximumStartIndex = line.length - line.minimumSectionLength,\n        i,\n        section,\n        possibleStartIndex,\n        newPossibleStartIndexes,\n        lineSectionKey,\n        startIndexKey,\n        testCell,\n        end,\n        lineCellKey,\n        lineKey;\n\n      // no sections\n\n      if (line.sections.length === 0) {\n        for (lineCellKey = 0; lineCellKey < line.cells.length; lineCellKey++) {\n          this._setCellSolution(line.cells[lineCellKey], 0);\n        }\n      }\n\n      // tighten range if one or more known negative cells start the line\n\n      for (lineKey = 0; lineKey < line.length; lineKey++) {\n        if (line.cells[lineKey].aiSolution === 0) {\n          minimumStartIndex++;\n        } else {\n          break;\n        }\n      }\n\n      // tighten range if one or more known negative cells end the line\n\n      for (lineKey = line.length - 1; lineKey >= 0; lineKey--) {\n        if (line.cells[lineKey].aiSolution === 0) {\n          maximumStartIndex--;\n        } else {\n          break;\n        }\n      }\n      for (lineSectionKey = 0; lineSectionKey < line.sections.length; lineSectionKey++) {\n        section = line.sections[lineSectionKey];\n        newPossibleStartIndexes = _src_utility_js__WEBPACK_IMPORTED_MODULE_1__.Utility.cloneArray(section.possibleStartIndexes);\n\n        // eliminate places where section does not fit\n\n        for (startIndexKey = 0; startIndexKey < section.possibleStartIndexes.length; startIndexKey++) {\n          possibleStartIndex = section.possibleStartIndexes[startIndexKey];\n          testCell = line.cells[possibleStartIndex + section.length];\n\n          // the total length of all sections including minimum gap(s) of one cell does not allow this section to fit:\n\n          if (possibleStartIndex < minimumStartIndex || possibleStartIndex > maximumStartIndex) {\n            newPossibleStartIndexes = _src_utility_js__WEBPACK_IMPORTED_MODULE_1__.Utility.removeFromArray(newPossibleStartIndexes, possibleStartIndex);\n          }\n\n          // there is a known positive cell immediately following the possible section placement, so section cannot start here\n\n          if (testCell && testCell.aiSolution === 1) {\n            newPossibleStartIndexes = _src_utility_js__WEBPACK_IMPORTED_MODULE_1__.Utility.removeFromArray(newPossibleStartIndexes, possibleStartIndex);\n          }\n\n          // there is a known impossible cell in this range, so section cannot fit here:\n\n          end = possibleStartIndex + section.length - 1;\n          end = end > line.length - 1 ? line.length - 1 : end;\n          for (i = possibleStartIndex; i <= end; i++) {\n            if (i > line.length - 1 || line.cells[i].aiSolution === 0) {\n              newPossibleStartIndexes = _src_utility_js__WEBPACK_IMPORTED_MODULE_1__.Utility.removeFromArray(newPossibleStartIndexes, possibleStartIndex);\n            }\n          }\n        }\n        minimumStartIndex += section.length + 1;\n        maximumStartIndex += section.length + 1;\n        section.possibleStartIndexes = newPossibleStartIndexes;\n      }\n    }\n\n    /**\r\n     *\r\n     * @param {PuzzleLine} line\r\n     */\n  }, {\n    key: \"findKnownPositivesAndNegatives\",\n    value: function findKnownPositivesAndNegatives(line) {\n      var totalCellCounts = _src_utility_js__WEBPACK_IMPORTED_MODULE_1__.Utility.getZeroFilledArray(line.length);\n      var sectionKey, section, cellCounts, startIndexKey, possibleStartIndex, start, end, i, cellCountKey, cellCount, cell;\n      for (sectionKey = 0; sectionKey < line.sections.length; sectionKey++) {\n        section = line.sections[sectionKey];\n        cellCounts = _src_utility_js__WEBPACK_IMPORTED_MODULE_1__.Utility.getZeroFilledArray(line.length);\n\n        // keep two counts: 1) all common cells for this section, and 2) cells where no section can be\n\n        for (startIndexKey = 0; startIndexKey < section.possibleStartIndexes.length; startIndexKey++) {\n          possibleStartIndex = section.possibleStartIndexes[startIndexKey];\n          start = possibleStartIndex;\n          end = start + section.length - 1;\n          for (i = start; i <= end; i++) {\n            cellCounts[i]++;\n            totalCellCounts[i]++;\n          }\n        }\n\n        // common to all possibilities, solve as positive\n\n        for (cellCountKey = 0; cellCountKey < cellCounts.length; cellCountKey++) {\n          cellCount = cellCounts[cellCountKey];\n          cell = line.cells[cellCountKey];\n          if (cell && cell.aiSolution === null && cellCount === section.possibleStartIndexes.length) {\n            this._setCellSolution(cell, 1);\n          }\n        }\n      }\n\n      // no possible cells, remove as a possibility\n\n      for (cellCountKey = 0; cellCountKey < totalCellCounts.length; cellCountKey++) {\n        cellCount = totalCellCounts[cellCountKey];\n        cell = line.cells[cellCountKey];\n        if (cell && cell.aiSolution === null && cellCount === 0) {\n          this._setCellSolution(cell, 0);\n        }\n      }\n    }\n\n    /**\r\n     *\r\n     * @param {PuzzleLine} line\r\n     */\n  }, {\n    key: \"findAnchoredSections\",\n    value: function findAnchoredSections(line) {\n      var i, fillRange, firstSection, lastSection;\n      if (line.sections.length > 0) {\n        firstSection = line.sections[0];\n        lastSection = line.sections[line.sections.length - 1];\n\n        // find sections anchored to start of line\n\n        fillRange = null;\n        for (i = 0; i < line.cells.length; i++) {\n          if (line.cells[i].aiSolution === null) {\n            break;\n          } else if (line.cells[i].aiSolution === 1) {\n            fillRange = [i, i + firstSection.length - 1];\n            break;\n          }\n        }\n        if (fillRange !== null) {\n          for (i = fillRange[0]; i <= fillRange[1]; i++) {\n            if (line.cells[i]) {\n              this._setCellSolution(line.cells[i], 1);\n            }\n          }\n          if (line.cells[i]) {\n            this._setCellSolution(line.cells[i], 0);\n          }\n        }\n\n        // find sections anchored to end of line\n\n        fillRange = null;\n        for (i = line.cells.length - 1; i >= 0; i--) {\n          if (line.cells[i].aiSolution === null) {\n            break;\n          } else if (line.cells[i].aiSolution === 1) {\n            fillRange = [i - lastSection.length + 1, i];\n            break;\n          }\n        }\n        if (fillRange !== null) {\n          for (i = fillRange[0]; i <= fillRange[1]; i++) {\n            if (line.cells[i]) {\n              this._setCellSolution(line.cells[i], 1);\n            }\n          }\n          if (line.cells[fillRange[0] - 1]) {\n            this._setCellSolution(line.cells[fillRange[0] - 1], 0);\n          }\n        }\n      }\n    }\n\n    /**\r\n     *\r\n     * @param {PuzzleLine} line\r\n     */\n  }, {\n    key: \"findSectionDefiningChains\",\n    value: function findSectionDefiningChains(line) {\n      var chains = [],\n        lastValue = 0,\n        cellKey,\n        cell,\n        chain,\n        chainKey,\n        sectionsSorted,\n        firstSortedSection;\n\n      // sort sections by highest length to lowest\n\n      sectionsSorted = _src_utility_js__WEBPACK_IMPORTED_MODULE_1__.Utility.cloneArray(line.sections).sort(function (a, b) {\n        return a.length > b.length ? -1 : 1;\n      });\n      firstSortedSection = sectionsSorted[0];\n\n      // loop through all cells, creating array of connectors\n\n      for (cellKey = 0; cellKey < line.cells.length; cellKey++) {\n        cell = line.cells[cellKey];\n        if (cell.aiSolution === 1) {\n          if (lastValue !== 1) {\n            chain = {\n              start: cellKey,\n              length: 1\n            };\n            chains.push(chain);\n          } else if (chain) {\n            chain.length++;\n          }\n        }\n        lastValue = cell.aiSolution;\n      }\n\n      // if a connector is found with the first section's length, place negatives around it and mark the section as complete & continue\n\n      for (chainKey = 0; chainKey < chains.length; chainKey++) {\n        chain = chains[chainKey];\n        if (chain.length === firstSortedSection.length) {\n          if (line.cells[chain.start - 1]) {\n            this._setCellSolution(line.cells[chain.start - 1], 0);\n          }\n          if (line.cells[chain.start + firstSortedSection.length]) {\n            this._setCellSolution(line.cells[chain.start + firstSortedSection.length], 0);\n          }\n          firstSortedSection.solved = true;\n        }\n      }\n    }\n\n    /**\r\n     *\r\n     * @param {PuzzleLine} line\r\n     */\n  }, {\n    key: \"findCompletedSections\",\n    value: function findCompletedSections(line) {\n      var sectionKey, section, firstNegative, lastNegative;\n\n      // complete lines where all sections have been found\n\n      for (sectionKey = 0; sectionKey < line.sections.length; sectionKey++) {\n        section = line.sections[sectionKey];\n\n        // only one possible place...\n\n        if (!section.solved && section.possibleStartIndexes.length === 1) {\n          // make sure there is a negative cell on either side of the section\n\n          firstNegative = section.possibleStartIndexes[0] - 1;\n          lastNegative = section.possibleStartIndexes[0] + section.length;\n          if (line.cells[firstNegative] && line.cells[firstNegative].aiSolution === null) {\n            this._setCellSolution(line.cells[firstNegative], 0);\n          }\n          if (line.cells[lastNegative] && line.cells[lastNegative].aiSolution === null) {\n            this._setCellSolution(line.cells[lastNegative], 0);\n          }\n          section.solved = true;\n        }\n      }\n    }\n\n    /**\r\n     *\r\n     * @param {PuzzleLine} line\r\n     */\n  }, {\n    key: \"findCompletedLines\",\n    value: function findCompletedLines(line) {\n      var totalSectionLength = 0,\n        totalPositiveSolved = 0,\n        sectionKey,\n        section,\n        cellKey,\n        cell;\n\n      // complete lines where all sections have been found\n\n      for (sectionKey = 0; sectionKey < line.sections.length; sectionKey++) {\n        section = line.sections[sectionKey];\n        totalSectionLength += section.length;\n      }\n      for (cellKey = 0; cellKey < line.cells.length; cellKey++) {\n        cell = line.cells[cellKey];\n        totalPositiveSolved += cell.aiSolution === 1;\n      }\n      if (totalSectionLength === totalPositiveSolved) {\n        for (cellKey = 0; cellKey < line.cells.length; cellKey++) {\n          cell = line.cells[cellKey];\n          if (cell.aiSolution === null) {\n            this._setCellSolution(cell, 0);\n          }\n        }\n      }\n    }\n\n    //\t#############################################################################################\tprivate methods\n\n    /**\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      var possibleRowIndexes = [],\n        possibleColumnIndexes = [];\n      var i, cellKey, rowNumber, rowHints, rowCells, line, index, len, columnKey, columnHint;\n      this.isReset = true;\n      this.elapsedTime = 0;\n      this.solutionLog = [];\n      this.lines = [];\n      this._log('Resetting variables', 'info');\n\n      // reset cell.aiSolution\n\n      for (cellKey = 0; cellKey < this.puzzle.cells.length; cellKey++) {\n        this.puzzle.cells[cellKey].aiSolution = null;\n      }\n\n      // reset possibleRowIndexes\n\n      for (i = 0; i < this.puzzle.width; i++) {\n        possibleRowIndexes.push(i);\n      }\n\n      // reset possibleColumnIndexes\n\n      for (i = 0; i < this.puzzle.height; i++) {\n        possibleColumnIndexes.push(i);\n      }\n\n      // reset rowHints\n\n      for (rowNumber = 0; rowNumber < this.puzzle.rowHints.length; rowNumber++) {\n        rowHints = this.puzzle.rowHints[rowNumber];\n        rowCells = this.puzzle.getRowCells(rowNumber);\n        if (rowCells) {\n          line = new _src_puzzle_line_js__WEBPACK_IMPORTED_MODULE_0__.PuzzleLine({\n            type: 'row',\n            index: rowNumber,\n            length: this.puzzle.width,\n            cells: rowCells\n          });\n          for (index = 0; index < rowHints.length; index++) {\n            len = rowHints[index];\n            line.sections.push({\n              index: index,\n              length: len,\n              possibleStartIndexes: possibleRowIndexes,\n              knownIndexes: [],\n              solved: false\n            });\n            line.minimumSectionLength += len + 1;\n          }\n          line.minimumSectionLength--;\n          this.lines.push(line);\n        }\n      }\n\n      // reset columnHints\n\n      for (columnKey = 0; columnKey < this.puzzle.columnHints.length; columnKey++) {\n        columnHint = this.puzzle.columnHints[columnKey];\n        line = new _src_puzzle_line_js__WEBPACK_IMPORTED_MODULE_0__.PuzzleLine({\n          type: 'column',\n          index: columnKey,\n          length: this.puzzle.height,\n          cells: this.puzzle.getColumnCells(columnKey)\n        });\n        for (index = 0; index < columnHint.length; index++) {\n          len = columnHint[index];\n          line.sections.push({\n            index: index,\n            length: len,\n            possibleStartIndexes: possibleColumnIndexes,\n            knownIndexes: [],\n            solved: false\n          });\n          line.minimumSectionLength += len + 1;\n        }\n        line.minimumSectionLength--;\n        this.lines.push(line);\n      }\n    }\n\n    /**\r\n     *\r\n     * @param {PuzzleCell} puzzleCell\r\n     * @param {number} value\r\n     * @private\r\n     */\n  }, {\n    key: \"_setCellSolution\",\n    value: function _setCellSolution(puzzleCell, value) {\n      var lineKey, line, isRow, isCol, cellsSolved, cellKey, cell;\n      if (puzzleCell.aiSolution !== null) {\n        return;\n      }\n      for (lineKey = 0; lineKey < this.lines.length; lineKey++) {\n        line = this.lines[lineKey];\n        isRow = line.type === 'row' && line.index === puzzleCell.row;\n        isCol = line.type === 'column' && line.index === puzzleCell.column;\n        cellsSolved = 0;\n        if (isRow || isCol) {\n          for (cellKey = 0; cellKey < line.cells.length; cellKey++) {\n            cell = line.cells[cellKey];\n            if (cell.index === puzzleCell.index) {\n              cell.aiSolution = value;\n              cellsSolved++;\n            } else if (cell.aiSolution !== null) {\n              cellsSolved++;\n            }\n          }\n          if (cellsSolved === line.length) {\n            line.solved = true;\n          }\n        }\n      }\n    }\n\n    /**\r\n     *\r\n     * @param html\r\n     * @param cssClass\r\n     * @private\r\n     */\n  }, {\n    key: \"_log\",\n    value: function _log(html, cssClass) {\n      this.solutionLog.push({\n        html: html,\n        cssClass: cssClass || 'info'\n      });\n    }\n\n    /**\r\n     *\r\n     * @returns {number}\r\n     * @private\r\n     */\n  }, {\n    key: \"_getTotalSolved\",\n    value: function _getTotalSolved() {\n      var total = 0,\n        cellKey;\n      for (cellKey = 0; cellKey < this.puzzle.cells.length; cellKey++) {\n        total += this.puzzle.cells[cellKey].aiSolution !== null;\n      }\n      return total;\n    }\n\n    /**\r\n     * calculate the maximum # of possible permutations, depending on the current state of the solving process.\r\n     *\r\n     * @returns {number}\r\n     * @private\r\n     */\n  }, {\n    key: \"_getProgress\",\n    value: function _getProgress() {\n      var maxPossibilities = 0,\n        totalPossibilities = 0,\n        lineKey,\n        line,\n        sectionKey;\n      for (lineKey = 0; lineKey < this.lines.length; lineKey++) {\n        line = this.lines[lineKey];\n        maxPossibilities += line.sections.length * (line.type === 'row' ? this.puzzle.width : this.puzzle.height);\n        for (sectionKey = 0; sectionKey < line.sections.length; sectionKey++) {\n          totalPossibilities += line.sections[sectionKey].possibleStartIndexes.length;\n        }\n      }\n      return maxPossibilities - totalPossibilities;\n    }\n  }]);\n  return Solver;\n}();\n\n//# sourceURL=webpack://Nonogram/./src/solver.js?");

/***/ }),

/***/ "./src/utility.js":
/*!************************!*\
  !*** ./src/utility.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utility: () => (/* binding */ Utility)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\r\n * @class\r\n * @type {Utility}\r\n * @this Utility\r\n */\nvar Utility = /*#__PURE__*/function () {\n  function Utility() {\n    _classCallCheck(this, Utility);\n  }\n  _createClass(Utility, null, [{\n    key: \"removeFromArray\",\n    value:\n    /**\r\n     *\r\n     * @param array\r\n     * @param value\r\n     * @returns {array}\r\n     */\n    function removeFromArray(array, value) {\n      var index = array.indexOf(value);\n      if (index !== -1) {\n        array.splice(index, 1);\n      }\n      return array;\n    }\n\n    /**\r\n     *\r\n     * @param length\r\n     * @returns {array}\r\n     */\n  }, {\n    key: \"getZeroFilledArray\",\n    value: function getZeroFilledArray(length) {\n      return new Array(length).fill(0);\n    }\n\n    /**\r\n     *\r\n     * @param array\r\n     * @returns {array}\r\n     */\n  }, {\n    key: \"cloneArray\",\n    value: function cloneArray(array) {\n      return array.slice(0);\n    }\n\n    /**\r\n     *\r\n     * @param min\r\n     * @param max\r\n     * @returns {number}\r\n     */\n  }, {\n    key: \"getRandomIntBetween\",\n    value: function getRandomIntBetween(min, max) {\n      var minCeil = Math.ceil(min),\n        maxFloor = Math.floor(max);\n      return Math.floor(Math.random() * (maxFloor - minCeil + 1)) + minCeil;\n    }\n  }]);\n  return Utility;\n}();\n\n//# sourceURL=webpack://Nonogram/./src/utility.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=nonogram.js.map